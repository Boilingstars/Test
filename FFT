// АНАЛИЗАТОР ЗВУКОВОГО СПЕКТРА
// Версия 1.0 от 31 августа 2023 г.
// За основу разработки взят проект Алекса Гайвера "Анализатор аудиоспектра", выполненный К.В. Пузановским.
// Программирование: Кирилл Пузановский.
// Тестирование: Кирилл Пузановский.
// Тестировалось на Arduino UNO

//--------------------------------------------СХЕМА ПОДКЛЮЧЕНИЯ---------------------------
// К VIN и GND крайне желательно подключить электролитический конденсатор большой ёмкости. Я установил 1000 мкФ.
// Микрофонный модуль MAX9814 подключается к Ф0
// Крайне желательно замкнуть контакты Gain и Vdd на плате MAX9814.


// сигнал
#define INPUT_GAIN 1.5    // коэффициент усиления входного сигнала
#define LOW_PASS 35       // нижний порог чувствительности шумов (нет скачков при отсутствии звука)
#define MAX_COEF 1.1      // коэффициент, который делает "максимальные" пики чуть меньше максимума, для более приятного восприятия
#define NORMALIZE 0       // нормализовать пики (столбики низких и высоких частот будут одинаковой длины при одинаковой громкости) (1 вкл, 0 выкл)

// громкость
#define DEF_GAIN 100       // максимальный порог по умолчанию (при MANUAL_GAIN или AUTO_GAIN игнорируется)
#define MANUAL_GAIN 0     // ручная настройка потенциометром на громкость (1 вкл, 0 выкл)
#define AUTO_GAIN 1       // автонастройка по громкости (экспериментальная функция) (1 вкл, 0 выкл)

// массив тонов, расположены примерно по параболе. От 80 Гц до 16 кГц
byte posOffset[33] = {
  2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 20, 25, 32, 36, 40, 44, 48, 52, 57, 62, 67, 72, 78, 84, 90, 96, 102, 108, 120
};

#define AUDIO_IN A0         // пин, куда подключен звук

#define FHT_N 256         // ширина спектра х2
#define LOG_OUT 1
#include <FHT.h>           // преобразование Хартли

#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))

int gain = DEF_GAIN;   // усиление по умолчанию
unsigned long gainTimer, fallTimer;
byte maxValue;
float k = 0.05, maxValue_f = 0.0;
int maxLevel[32];
byte posLevel_old[32];
unsigned long timeLevel[32], mainDelay;
boolean fallFlag;


void setup() {
  Serial.begin(115200);

  // поднимаем частоту опроса аналогового порта до 38.4 кГц, по теореме
  // Котельникова (Найквиста) максимальная частота дискретизации будет 19 кГц
  // http://yaab-arduino.blogspot.ru/2015/02/fast-sampling-from-analog-input.html
  sbi(ADCSRA, ADPS2);
  cbi(ADCSRA, ADPS1);
  sbi(ADCSRA, ADPS0);

  //analogReference(EXTERNAL);
}

//void loop() {
//  for (int i = 0 ; i < FHT_N ; i++) {
//    int sample = analogRead(MIC_PIN);
//    fht_input[i] = sample; // put real data into bins
//  }
//  fht_window();  // window the data for better frequency response
//  fht_reorder(); // reorder the data before doing the fht
//  fht_run();     // process the data in the fht
//  fht_mag_log(); // take the output of the fht
//
//  for (int curBin = 0; curBin < FHT_N / 2; ++curBin) {
//    Serial.print(fht_log_out[curBin]);
//    Serial.print(" ");
//  }
//  Serial.println("");
//  delay(500);
//}



void loop() {
  if (millis() - mainDelay >  2) {     // итерация главного цикла
    mainDelay = millis();

    analyzeAudio();   // функция FHT, забивает массив fht_log_out[] величинами по спектру

    for (int i = 0; i < 128; i ++) {
      // вот здесь сразу фильтруем весь спектр по минимальному LOW_PASS
      if (fht_log_out[i] < LOW_PASS) fht_log_out[i] = 0;

      // усиляем сигнал
      fht_log_out[i] = (float)fht_log_out[i] * INPUT_GAIN;

      // уменьшаем громкость высоких частот (пропорционально частоте) если включено
      if (NORMALIZE) fht_log_out[i] = (float)fht_log_out[i] / ((float)1 + (float)i / 128);
    }
    maxValue = 0;

for (byte pos = 0; pos < 32; pos++) {    // для кажого столбца матрицы
      int posLevel = fht_log_out[posOffset[pos]];
      byte linesBetween;
      if (pos > 0 && pos < 32) {
        linesBetween = posOffset[pos] - posOffset[pos - 1];
        for (byte i = 0; i < linesBetween; i++) {  // от предыдущей полосы до текущей
          posLevel += (float) ((float)i / linesBetween) * fht_log_out[posOffset[pos] - linesBetween + i];
        }
        linesBetween = posOffset[pos + 1] - posOffset[pos];
        for (byte i = 0; i < linesBetween; i++) {  // от предыдущей полосы до текущей
          posLevel += (float) ((float)i / linesBetween) * fht_log_out[posOffset[pos] + linesBetween - i];
        }
      }


      // преобразовать значение величины спектра в диапазон 0..7 с учётом настроек
      posLevel = map(posLevel, LOW_PASS, gain, 0, 128);
      posLevel = constrain(posLevel, 0, 128);
      Serial.print(posLevel);
      Serial.print(" ");
    }
    Serial.println(" ");
    //    for (byte pos = 0; pos < 32; pos++) {    // для кажого столбца матрицы


    //   }


    // если разрешена авто настройка уровня громкости
    if (AUTO_GAIN) {
      if (millis() - gainTimer > 10) {      // каждые 10 мс
        maxValue_f = maxValue * k + maxValue_f * (1 - k);
        // если максимальное значение больше порога, взять его как максимум для отображения
        if (maxValue_f > LOW_PASS) gain = (float) MAX_COEF * maxValue_f;
        // если нет, то взять порог побольше, чтобы шумы вообще не проходили
        else gain = 100;
        gainTimer = millis();
      }
    }
  }
}

void analyzeAudio() {
  for (int i = 0 ; i < FHT_N ; i++) {
    int sample = analogRead(AUDIO_IN);
    fht_input[i] = sample; // put real data into bins
  }
  fht_window();  // window the data for better frequency response
  fht_reorder(); // reorder the data before doing the fht
  fht_run();     // process the data in the fht
  fht_mag_log(); // take the output of the fht
}

/*
   Алгоритм работы:
   Анализ спектра, на выходе имеем массив величин полос спектра (128 полос)
   Фильтрация по нижним значениям для каждой полосы (128 полос)
   Переход от 128 полос к 16 полосам с сохранением межполосных значений по линейной зависимости
   Поиск максимумов для коррекции высоты столбиков на матрице
   Перевод чистого "веса" полосы к высоте матрицы
   Отправка полос на матрицу
   Расчёт позиций точек максимума и отправка их на мтарицу

   Мимоходом фильтрация верхних пиков, коррекция высоты столбиков от громкости и прочее
*/